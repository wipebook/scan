<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Edge-Tracking Camera (Final)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    .app { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr auto; }
    .stage { position: relative; overflow: hidden; background: #000; }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
    #overlay { pointer-events: none; }
    #status { position: absolute; bottom: 110px; left: 50%; transform: translateX(-50%); color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; font-size: 14px; background: rgba(0,0,0,.45); padding: 6px 10px; border-radius: 8px; z-index: 1; }
    
    .controls {
        display: grid;
        place-items: center;
        background: #000;
        padding: 14px 16px calc(14px + env(safe-area-inset-bottom));
        position: relative;
    }

    #capture { width: 72px; height: 72px; border-radius: 999px; border: 6px solid #eee; background: rgba(255,255,255,0.06); box-shadow: 0 0 0 2px rgba(255,255,255,.15) inset; cursor: pointer; transition: transform 0.2s, border-color 0.2s, background-color 0.2s; }
    #toast { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); color: #fff; background: #d9534f; padding: 8px 12px; border-radius: 8px; display:none; font-family: system-ui; font-size: 12px; }

    #capture:disabled {
        cursor: not-allowed;
        opacity: 0.8;
    }
    
    #capture.loading {
        animation: spin 1s linear infinite;
        border-color: rgba(238, 238, 238, 0.3);
        border-top-color: #eee;
        background: transparent;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="stage">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
        <div id="status">Initializing…</div>
    </div>
    <div class="controls">
        <button id="capture" title="Capture & Download"></button>
    </div>
  </div>
  <div id="toast"></div>

  <canvas id="proc" style="display:none;"></canvas>
  <canvas id="crop" style="display:none;"></canvas>

<script>
'use strict';
(function(){
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');
  const proc = document.getElementById('proc');
  const pctx = proc.getContext('2d', { willReadFrequently: true });
  const crop = document.getElementById('crop');
  const statusEl = document.getElementById('status');
  const toast = document.getElementById('toast');
  const captureBtn = document.getElementById('capture');

  let imageCapture = null;

  function showToast(msg){
    toast.textContent = msg; toast.style.display='block';
    clearTimeout(showToast._t); showToast._t = setTimeout(()=> toast.style.display='none', 3000);
  }

  function resizeOverlay(){
    const r = overlay.getBoundingClientRect();
    overlay.width = Math.round(r.width);
    overlay.height = Math.round(r.height);
  }
  addEventListener('resize', resizeOverlay);

  const PROC_W = 320;
  let PROC_H = 240;

  let lastQuad = null;
  let stableFrames = 0;

  function lerp(a,b,t){ return a + (b-a)*t; }
  
  function drawOverlay(quad){
    octx.clearRect(0,0,overlay.width,overlay.height);
    if (!quad) return;
    octx.lineWidth = 3; octx.strokeStyle='rgba(0,200,255,.95)'; octx.fillStyle='rgba(0,200,255,.12)';
    const [tl, tr, br, bl] = quad;
    octx.beginPath();
    octx.moveTo(tl.x, tl.y); octx.lineTo(tr.x, tr.y); octx.lineTo(br.x, br.y); octx.lineTo(bl.x, bl.y);
    octx.closePath(); octx.stroke(); octx.fill();
  }

  function procToScreen(px, py){
    const vw = overlay.width, vh = overlay.height;
    const vidW = video.videoWidth, vidH = video.videoHeight;
    const vidAR = vidW/vidH, viewAR = vw/vh;
    let scale, ox=0, oy=0;
    if (vidAR > viewAR){ scale = vh/vidH; ox = (vw - vidW*scale)/2; }
    else { scale = vw/vidW; oy = (vh - vidH*scale)/2; }
    const sx = ox + (px/PROC_W) * (vidW*scale);
    const sy = oy + (py/PROC_H) * (vidH*scale);
    return { x: sx, y: sy };
  }

  function harrisCorners(gray, W, H) {
      const corners = [];
      const R = new Float32Array(W*H), K = 0.05, THRESHOLD = 250;
      const Ix = new Float32Array(W*H), Iy = new Float32Array(W*H);
      for (let y=1; y<H-1; y++) for (let x=1; x<W-1; x++) {
          const gx = (gray[(y-1)*(W)+(x+1)] + 2*gray[y*W+(x+1)] + gray[(y+1)*W+(x+1)]) - (gray[(y-1)*(W)+(x-1)] + 2*gray[y*W+(x-1)] + gray[(y+1)*W+(x-1)]);
          const gy = (gray[(y+1)*(W)+(x-1)] + 2*gray[(y+1)*W+x] + gray[(y+1)*W+(x+1)]) - (gray[(y-1)*(W)+(x-1)] + 2*gray[(y-1)*W+x] + gray[(y-1)*W+(x+1)]);
          Ix[y*W+x] = gx; Iy[y*W+x] = gy;
      }
      const Ixx = new Float32Array(W*H), Iyy = new Float32Array(W*H), Ixy = new Float32Array(W*H);
      for (let i=0; i<W*H; i++) { Ixx[i] = Ix[i]*Ix[i]; Iyy[i] = Iy[i]*Iy[i]; Ixy[i] = Ix[i]*Iy[i]; }
      const Sxx = new Float32Array(W*H), Syy = new Float32Array(W*H), Sxy = new Float32Array(W*H);
      const WIN_SIZE = 5, WIN_HALF = Math.floor(WIN_SIZE/2);
      for (let y=WIN_HALF; y<H-WIN_HALF; y++) for (let x=WIN_HALF; x<W-WIN_HALF; x++) {
          let sxx=0, syy=0, sxy=0;
          for(let wy=-WIN_HALF; wy<=WIN_HALF; wy++) for(let wx=-WIN_HALF; wx<=WIN_HALF; wx++) {
              const i = (y+wy)*W + (x+wx); sxx += Ixx[i]; syy += Iyy[i]; sxy += Ixy[i];
          }
          Sxx[y*W+x] = sxx; Syy[y*W+x] = syy; Sxy[y*W+x] = sxy;
      }
      for (let i=0; i<W*H; i++) {
          const det = (Sxx[i]*Syy[i]) - (Sxy[i]*Sxy[i]);
          const trace = Sxx[i] + Syy[i];
          R[i] = det - K * (trace*trace);
      }
      for (let y=1; y<H-1; y++) for (let x=1; x<W-1; x++) {
          const score = R[y*W+x];
          if (score > THRESHOLD) {
              let isMax = true;
              for (let ny=-1; ny<=1; ny++) { for (let nx=-1; nx<=1; nx++) if (R[(y+ny)*W+(x+nx)] > score) { isMax=false; break; } if(!isMax) break; }
              if (isMax) corners.push({ x:x, y:y, score:score });
          }
      }
      return corners;
  }
  
  function createDefaultQuad(W, H) {
      const paddingX = W*0.125, paddingY = H*0.125;
      return [ { x: paddingX, y: paddingY }, { x: W-paddingX, y: paddingY }, { x: W-paddingX, y: H-paddingY }, { x: paddingX, y: H-paddingY } ];
  }

  function refineQuadWithCorners(initialQuad, corners) {
      const refinedQuad = initialQuad.map(p => ({...p}));
      const SEARCH_RADIUS = PROC_W * 0.4;
      for (let i = 0; i < 4; i++) {
          const defaultCorner = initialQuad[i];
          let bestCandidate = defaultCorner;
          let bestScore = -1;
          for (const p of corners) {
              const dist = Math.hypot(p.x - defaultCorner.x, p.y - defaultCorner.y);
              if (dist < SEARCH_RADIUS && p.score > bestScore) { bestScore = p.score; bestCandidate = p; }
          }
          refinedQuad[i] = bestCandidate;
      }
      return refinedQuad;
  }

  function processFrame(){
    const vw = video.videoWidth, vh = video.videoHeight;
    if(!vw || !vh) { requestAnimationFrame(processFrame); return; }
    resizeOverlay();
    PROC_H = Math.round(PROC_W * vh / vw);
    if(proc.width !== PROC_W || proc.height !== PROC_H){ proc.width = PROC_W; proc.height = PROC_H; }
    
    pctx.drawImage(video, 0, 0, PROC_W, PROC_H);
    const frame = pctx.getImageData(0,0,PROC_W,PROC_H);
    const data = frame.data; const gray = new Uint8ClampedArray(PROC_W*PROC_H);
    for(let i=0,j=0;i<data.length;i+=4,j++){ gray[j] = (0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2])|0; }
    
    // Reverted to the stable rectangular detection logic
    const corners = harrisCorners(gray, PROC_W, PROC_H);
    const defaultQuad = createDefaultQuad(PROC_W, PROC_H);
    const refinedCorners = refineQuadWithCorners(defaultQuad, corners);

    let minX = PROC_W, minY = PROC_H, maxX = 0, maxY = 0;
    for(const p of refinedCorners) {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
    }
    const ptsProc = [ { x: minX, y: minY }, { x: maxX, y: minY }, { x: maxX, y: maxY }, { x: minX, y: maxY } ];

    const quad = ptsProc.map(p => procToScreen(p.x, p.y));
    if(lastQuad){ for(let i=0;i<4;i++){ quad[i] = { x: lerp(lastQuad[i].x, quad[i].x, 0.5), y: lerp(lastQuad[i].y, quad[i].y, 0.5) }; } }
    
    let diff = 0;
    const defaultScreenQuad = defaultQuad.map(p => procToScreen(p.x, p.y));
    for (let i=0; i<4; i++) { diff += Math.hypot(quad[i].x - defaultScreenQuad[i].x, quad[i].y - defaultScreenQuad[i].y); }
    if (diff > 20) { stableFrames = Math.min(stableFrames + 1, 60); }
    else { stableFrames = Math.max(0, stableFrames - 1); }
    statusEl.textContent = stableFrames > 5 ? 'Locked' : 'Detecting…'; 
    lastQuad = quad;
    drawOverlay(lastQuad);
    requestAnimationFrame(processFrame);
  }
  
  captureBtn.addEventListener('click', async () => {
    if(!lastQuad || captureBtn.disabled){ showToast('No page detected'); return; }
    if (!imageCapture) { showToast('ImageCapture not available'); return; }
    
    captureBtn.disabled = true;
    captureBtn.classList.add('loading');
    
    const processPromise = new Promise(async (resolve, reject) => {
        try {
            const photoBlob = await imageCapture.takePhoto();
            const imageBitmap = await createImageBitmap(photoBlob);

            const screenToPhoto = (sx, sy) => {
              const vw = overlay.width, vh = overlay.height;
              const vidW=video.videoWidth, vidH=video.videoHeight;
              const vidAR=vidW/vidH, viewAR=vw/vh;
              let scale, ox=0, oy=0;
              if(vidAR>viewAR){ scale = vh/vidH; ox=(vw-vidW*scale)/2; } else { scale = vw/vidW; oy=(vh-vidH*scale)/2; }
              const videoPercentX = (sx - ox) / (vidW * scale);
              const videoPercentY = (sy - oy) / (vidH * scale);
              
              const photoAR = imageBitmap.width / imageBitmap.height;
              let photoCropW, photoCropH, cropOffsetX=0, cropOffsetY=0;
              if (Math.abs(photoAR - vidAR) > 0.01) {
                  if (photoAR > vidAR) {
                      photoCropH = imageBitmap.height;
                      photoCropW = photoCropH * vidAR;
                      cropOffsetX = (imageBitmap.width - photoCropW)/2;
                  } else {
                      photoCropW = imageBitmap.width;
                      photoCropH = photoCropW / vidAR;
                      cropOffsetY = (imageBitmap.height - photoCropH)/2;
                  }
              } else {
                  photoCropW = imageBitmap.width;
                  photoCropH = imageBitmap.height;
              }
              return { x: cropOffsetX + videoPercentX * photoCropW, y: cropOffsetY + videoPercentY * photoCropH };
            }
            
            const [tl_s, tr_s, br_s, bl_s] = lastQuad;
            const cropTl = screenToPhoto(tl_s.x, tl_s.y);
            const cropBr = screenToPhoto(br_s.x, br_s.y);
            
            const sX = cropTl.x, sY = cropTl.y;
            const sWidth = cropBr.x - cropTl.x;
            const sHeight = cropBr.y - cropTl.y;

            if (sWidth <= 0 || sHeight <= 0) {
              return reject(new Error("Invalid crop dimensions"));
            }

            // High-resolution output logic
            const TARGET_LONGEST_SIDE = 1800;
            let outW, outH;
            if (sWidth > sHeight) {
                outW = TARGET_LONGEST_SIDE;
                outH = Math.round(TARGET_LONGEST_SIDE * (sHeight / sWidth));
            } else {
                outH = TARGET_LONGEST_SIDE;
                outW = Math.round(TARGET_LONGEST_SIDE * (sWidth / sHeight));
            }

            crop.width = outW;
            crop.height = outH;
            const cropCtx = crop.getContext('2d');
            
            // Use 9-argument drawImage for a high-quality crop and resize
            cropCtx.drawImage(imageBitmap, sX, sY, sWidth, sHeight, 0, 0, outW, outH);

            crop.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=`scan-${Date.now()}.jpg`; a.click(); URL.revokeObjectURL(a.href); resolve(); }, 'image/jpeg', 0.92);
        } catch(e) { reject(e); }
    });
    
    let loadingAnimationId;
    requestAnimationFrame(function animate(){
        if (!captureBtn.disabled) {
            captureBtn.style.transform = 'rotate(0deg)';
            return;
        }
        loadingAnimationId = requestAnimationFrame(animate);
    });
    
    try {
        await processPromise;
    } catch(e) {
        console.error(e);
        showToast(e.message || 'Image processing failed.');
    } finally {
        cancelAnimationFrame(loadingAnimationId);
        captureBtn.classList.remove('loading');
        captureBtn.disabled = false;
    }
  });

  (async function init(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio:false });
      video.srcObject = stream;
      await new Promise(res => video.addEventListener('loadedmetadata', res, { once: true }));
      video.play();
      
      const track = stream.getVideoTracks()[0];
      imageCapture = new ImageCapture(track);

      resizeOverlay();
      statusEl.textContent='Detecting…';
      requestAnimationFrame(processFrame);
    }catch(e){ statusEl.textContent='Camera error'; console.error(e); showToast('Camera access denied/unavailable'); }
  })();
})();
</script>
</body>
</html>